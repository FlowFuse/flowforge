const PACKAGE_ROOT = "../../../"
const path = require("path");
const FFRequire = file => require(path.join(PACKAGE_ROOT,file))
const { LocalTransport } = require('./forge/postoffice/localTransport.js')
const Forge = FFRequire('forge/forge.js')

async function setupApp (config = {}) {
    process.env.FF_TELEMETRY_DISABLED = true
    config = {
        telemetry: { enabled: false },
        logging: {
            level: 'warn'
        },
        db: {
            type: 'sqlite',
            storage: ':memory:'
        },
        email: {
            enabled: true,
            transport: new LocalTransport()
        },
        driver: {
            type: 'stub'
        },
        broker: {
            url: ':test:'
        },
        ...config
    }

    const testLimits = config.limits
    delete config.limits

    if (process.env.FF_TEST_DB_POSTGRES) {
        config.db.type = 'postgres'
        config.db.host = process.env.FF_TEST_DB_POSTGRES_HOST || 'localhost'
        config.db.port = process.env.FF_TEST_DB_POSTGRES_PORT || 5432
        config.db.user = process.env.FF_TEST_DB_POSTGRES_USER || 'postgres'
        config.db.password = process.env.FF_TEST_DB_POSTGRES_PASSWORD || 'secret'
        config.db.database = process.env.FF_TEST_DB_POSTGRES_DATABASE || 'flowforge_test'

        try {
            const { Client } = require('pg')
            const client = new Client({
                host: config.db.host,
                port: config.db.port,
                user: config.db.user,
                password: config.db.password
            })
            await client.connect()
            try {
                await client.query(`DROP DATABASE IF EXISTS ${config.db.database}`)
            } catch (err) {
                // Don't mind if it doesn't exist
            }
            await client.query(`CREATE DATABASE ${config.db.database}`)
            await client.end()
        } catch (err) {
            console.log(err.toString())
            process.exit(1)
        }
    } else if (process.env.FF_TEST_DB_MSSQL) {
        config.db.type = 'mssql'
        config.db.host = process.env.FF_TEST_DB_MSSQL_HOST || 'localhost'
        config.db.port = process.env.FF_TEST_DB_MSSQL_PORT || 1433
        config.db.user = process.env.FF_TEST_DB_MSSQL_USER || 'sa'
        config.db.password = process.env.FF_TEST_DB_MSSQL_PASSWORD || 'Secret123!'
        config.db.database = process.env.FF_TEST_DB_MSSQL_DATABASE || 'flowforge_test'
        
        try {
            const { Connection, Request } = require('tedious')
            const mssqlConfig = {
                server: config.db.host,
                authentication: {
                    type: 'default',
                    options: {
                        userName: config.db.user,
                        password: config.db.password
                    }
                },
                options: {
                    encrypt: false,
                    database: 'master',
                    trustServerCertificate: true
                }
            }
            async function connectToSqlServer(config) {
                return new Promise((resolve, reject) => {
                    const connection = new Connection(config);
                    connection.on('connect', err => {
                        if (err) {
                            reject(err);
                        } else {
                            resolve(connection);
                        }
                    });
                    connection.connect();
                });
            }
            async function executeQuery(connection, query) {
                return new Promise((resolve, reject) => {
                    const request = new Request(query, (err, _rowCount) => {
                        if (err) {
                            reject(err)
                        }
                    })

                    const results = []
                    request.on('row', (columns) => {
                        const row = {}
                        columns.forEach((column) => {
                            row[column.metadata.colName] = column.value
                        })
                        results.push(row)
                    })
                    request.on('requestCompleted', () => {
                        resolve(results)
                    })
                    connection.execSql(request)
                })
            }
            const connection = await connectToSqlServer(mssqlConfig)
            // see if the database already exists
            const existsQuery = `SELECT name FROM master.sys.databases WHERE name = '${config.db.database}'`
            try {
                const data = await executeQuery(connection, existsQuery)
                if (data.length > 0) {
                    const dropQuery = `
                    use master;
                    alter database [${config.db.database}] set single_user with rollback immediate;
                    drop DATABASE ${config.db.database};`
                    await executeQuery(connection, dropQuery)
                }
            } catch (err) {
                console.warn('Error checking/dropping database:', err)
                // Don't mind if errors
            }
            // By default, SQL Server collation is case-insensitive, PG and SQLite are case-sensitive
            // To avoid issues with case-insensitivity, we use a case-sensitive collation
            await executeQuery(connection, `CREATE DATABASE ${config.db.database} COLLATE Latin1_General_BIN;`)
            const exists = await executeQuery(connection, existsQuery)
            if (exists.length !== 1) {
                throw new Error('Database creation failed. Database does not exist after creation')
            }
        } catch (err) {
            console.warn('Error setting up MSSQL database:', err)
            process.exit(1)
        }
    }

    const app = await Forge({ config })

    // Allow platform limits to be overriden by tests
    if (testLimits) {
        for (const [key, value] of Object.entries(testLimits)) {
            app.license.defaults[key] = value
        }
    }
    return app
}


module.exports = {
    require: FFRequire,
    resolve: file => path.resolve(path.join(__dirname,PACKAGE_ROOT,file)),
    setupApp
}

/**
 * Local Container driver
 *
 * Handles the creation and deletation of containers to back Projects
 *
 * This driver creates Projects backed by userDirectories on the local file system
 *
 * @module localfs
 * @memberof forge.containers.drivers
 *
 */

const fs = require('fs');
const ps = require('ps');
const path = require('path');
const childProcess = require('child_process');

const initalPortNumber = 1880

function getNextFreePort(ports) {
  ports.sort((a,b) => {return a-b});
  let offset = ports[0];
  let lowest = -1;
  for (i=0; i<ports.length; ++i) {
    if (ports[i] != offset) {
      lowest = offset;
      break;
    }
    offset++
  }
  if (lowest == -1) {
    if (ports.length != 0) {
      lowest = this.ports[ports.length -1] + 1;
    } else {
      lowest = initalPortNumber
    }
  }
  return lowest
}

module.exports = {
  /**
   * Initialises this driver
   * @param {string} app - the Vue application
   * @param {object} options - A set of configuration options for the driver
   * @return {forge.containers.ProjectArguments}
   */
  init: async (app, options) => {
    this._app = app
    this._options = options
    this._projects = {}
    this._usedPorts = []
    this._rootDir = process.env["LOCALFS_ROOT"] || path.join(__dirname, "../../localfs_root")

    require('./models/Project')(app.db)

    if (!fs.existsSync(this._rootDir)) {
      fs.mkdirSync(this._rootDir)
    }

    //TODO need to check DB and see if the pids exist
    let projects = await this._app.db.models.LocalFSProject.findAll()
    console.log(projects)

    projects.forEach(async (project) => {
      let [proc] = await ps({pid: project.pid})
      this._usedPorts.push(project.port)
      console.log(proc)
      if (!proc) {
        //need to restart here
        this._usedPorts.push(project.port);
        let proc = childProcess.spawn(execPath,[
          '-u',
          project.path,
          '-p',
          project.port
          ],{
            detached: true,
            stdio: 'ignore'
          })

          proc.unref();

          project.pid = proc.pid;
          project.save();
      } else {
        //need to check if PID is actually Node-RED
        //current best we can do with the ps node is check if process is node

      }
    })

    //nothing to expose at the moment
    return {}
  },
   /**
   * Create a new Project
   * @param {string} id - id for the project
   * @param {forge.containers.Options} options - options for the project
   * @return {forge.containers.Project}
   */
  create: async (id, options) => {

    let directory = path.join(this._rootDir, id)
    if (!fs.existsSync(directory)) {
      fs.mkdirSync(directory)
    }

    if (options.port && this._usedPorts.contains(port)) {
      // error port in use so set it zero to get the next
      options.port = 0
    }
    var port = options.port || getNextFreePort(this._usedPorts);

    this._usedPorts.push(port);

    let execPath = path.join(__dirname,"node_modules/.bin/node-red")

    let proc = childProcess.spawn(execPath,[
      "-u",
      directory,
      "-p",
      port
      ],{
         detached: true,
         stdio: 'ignore'
      })

    console.log("PID",proc.pid, "port", port, "directory", directory)

    await this._app.db.models.LocalFSProject.create({
      id: id,
      pid: proc.pid,
      path: directory,
      port: port,
      state: "running"
    })

    this._projects[id] = {
      process: proc.pid,
      dir: directory,
      port: port,
      state: "running"
    }

    proc.unref();

    return Promise.resolve({
      id: id,
      status: "okay",
      url: "http://localhost:" + port,
      meta: {
        port: port
      }
    })
  },
  /**
   * Removes a Project
   * @param {string} id - id of project to remove
   * @return {Object}
   */
  remove: async (id) => {

    let project = await this._app.db.models.LocalFSProject.byId(id);

    if (project) {
      process.kill(project.pid,'SIGTERM')

      setTimeout(() => {
        fs.rmdirSync(project.path,{recursive: true, force: true})
      }, 5000)

      project.destroy()

      delete this._projects[id]

      return Promise.resolve({
        status: "okay"
      })
    } else {
      return Promise.reject({
        err: "project not found"
      })
    }


  },
  /**
    * Retrieves details of a project's container
    * @param {string} id - id of project to query
    * @return {Object}
    */
  details: async (id) => {
    return Promise.resolve(this._projects[id])
  },
  /**
   * Lists all containers
   * @param {string} filter - rules to filter the containers
   * @return {Object}
   */
  list: async (filter) => {

  },
  /**
   * Starts a Project's container
   * @param {string} id - id of project to start
   * @return {forge.Status}
   */
  start: async (id) => {

    let project = await this._app.db.models.LocalFSProject.byId(id)

    let proc = childProcess.spawn('node-red',[
      "-u",
      project.path,
      "-p",
      project.port
      ],{
        detached: true,
        stdio: 'ignore'
      })

    proc.unref()

    project.state = "running"
    project.save()

    return Promise.resolve({status: "okay"})
  },
  /**
   * Stop a Project's container
   * @param {string} id - id of project to stop
   * @return {forge.Status}
   */
  stop: async (id) => {

    let project = await this._app.db.models.LocalFSProject.byId(id)

    process.kill(project.pid,'SIGTERM')

    project.state = "stopped";
    project.save()
    return Promise.resolve({status: "okay"})
  },
  /**
   * Restarts a Project's container
   * @param {string} id - id of project to restart
   * @return {forge.Status}
   */
  restart: async (id) => {
    let rep = await stop(id);
    if (rep.status && rep.state === 'okay') {
      return await start(id);
    } else {
      return rep
    }
  }
}
